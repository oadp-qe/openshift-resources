# generated by datamodel-codegen:
#   filename:  k8s_swagger.json
#   timestamp: 2022-10-29T09:10:36+00:00

from __future__ import annotations

from datetime import datetime
from typing import Dict, List, Optional

from pydantic import BaseModel, Field

from ...k8s.apimachinery.pkg.apis.meta import v1


class Cpu(BaseModel):
    balanceIsolated: Optional[bool] = Field(
        None,
        description='BalanceIsolated toggles whether or not the Isolated CPU set is eligible for load balancing work loads. When this option is set to "false", the Isolated CPU set will be static, meaning workloads have to explicitly assign each thread to a specific cpu in order to work across multiple CPUs. Setting this to "true" allows workloads to be balanced across CPUs. Setting this to "false" offers the most predictable performance for guaranteed workloads, but it offloads the complexity of cpu load balancing to the application. Defaults to "true"',
    )
    isolated: str = Field(
        ...,
        description='Isolated defines a set of CPUs that will be used to give to application threads the most execution time possible, which means removing as many extraneous tasks off a CPU as possible. It is important to notice the CPU manager can choose any CPU to run the workload except the reserved CPUs. In order to guarantee that your workload will run on the isolated CPU:   1. The union of reserved CPUs and isolated CPUs should include all online CPUs   2. The isolated CPUs field should be the complementary to reserved CPUs field',
    )
    offlined: Optional[str] = Field(
        None,
        description='Offline defines a set of CPUs that will be unused and set offline',
    )
    reserved: Optional[str] = Field(
        None,
        description='Reserved defines a set of CPUs that will not be used for any container workloads initiated by kubelet.',
    )


class Page(BaseModel):
    count: Optional[int] = Field(
        None,
        description="Count defines amount of huge pages, maps to the 'hugepages' kernel boot parameter.",
    )
    node: Optional[int] = Field(
        None,
        description='Node defines the NUMA node where hugepages will be allocated, if not specified, pages will be allocated equally between NUMA nodes',
    )
    size: Optional[str] = Field(
        None,
        description="Size defines huge page size, maps to the 'hugepagesz' kernel boot parameter.",
    )


class Hugepages(BaseModel):
    defaultHugepagesSize: Optional[str] = Field(
        None,
        description='DefaultHugePagesSize defines huge pages default size under kernel boot parameters.',
    )
    pages: Optional[List[Page]] = Field(
        None,
        description='Pages defines huge pages that we want to allocate at boot time.',
    )


class Device(BaseModel):
    deviceID: Optional[str] = Field(
        None,
        description='Network device ID (model) represnted as a 16 bit hexmadecimal number.',
    )
    interfaceName: Optional[str] = Field(
        None,
        description='Network device name to be matched. It uses a syntax of shell-style wildcards which are either positive or negative.',
    )
    vendorID: Optional[str] = Field(
        None,
        description='Network device vendor ID represnted as a 16 bit Hexmadecimal number.',
    )


class Net(BaseModel):
    devices: Optional[List[Device]] = Field(
        None,
        description='Devices contains a list of network device representations that will be set with a netqueue count equal to CPU.Reserved . If no devices are specified then the default is all devices.',
    )
    userLevelNetworking: Optional[bool] = Field(
        None,
        description='UserLevelNetworking when enabled - sets either all or specified network devices queue size to the amount of reserved CPUs. Defaults to "false".',
    )


class Numa(BaseModel):
    topologyPolicy: Optional[str] = Field(
        None,
        description='Name of the policy applied when TopologyManager is enabled Operator defaults to "best-effort"',
    )


class RealTimeKernel(BaseModel):
    enabled: Optional[bool] = Field(
        None,
        description='Enabled defines if the real time kernel packages should be installed. Defaults to "false"',
    )


class WorkloadHints(BaseModel):
    highPowerConsumption: Optional[bool] = Field(
        None,
        description='HighPowerConsumption defines if the node should be configured in high power consumption mode. The flag will affect the power consumption but will improve the CPUs latency.',
    )
    realTime: Optional[bool] = Field(
        None,
        description='RealTime defines if the node should be configured for the real time workload.',
    )


class Spec(BaseModel):
    additionalKernelArgs: Optional[List[str]] = Field(
        None, description='Addional kernel arguments.'
    )
    cpu: Cpu = Field(..., description='CPU defines a set of CPU related parameters.')
    globallyDisableIrqLoadBalancing: Optional[bool] = Field(
        None,
        description='GloballyDisableIrqLoadBalancing toggles whether IRQ load balancing will be disabled for the Isolated CPU set. When the option is set to "true" it disables IRQs load balancing for the Isolated CPU set. Setting the option to "false" allows the IRQs to be balanced across all CPUs, however the IRQs load balancing can be disabled per pod CPUs when using irq-load-balancing.crio.io/cpu-quota.crio.io annotations. Defaults to "false"',
    )
    hugepages: Optional[Hugepages] = Field(
        None,
        description='HugePages defines a set of huge pages related parameters. It is possible to set huge pages with multiple size values at the same time. For example, hugepages can be set with 1G and 2M, both values will be set on the node by the performance-addon-operator. It is important to notice that setting hugepages default size to 1G will remove all 2M related folders from the node and it will be impossible to configure 2M hugepages under the node.',
    )
    machineConfigLabel: Optional[Dict[str, str]] = Field(
        None,
        description='MachineConfigLabel defines the label to add to the MachineConfigs the operator creates. It has to be used in the MachineConfigSelector of the MachineConfigPool which targets this performance profile. Defaults to "machineconfiguration.openshift.io/role=<same role as in NodeSelector label key>"',
    )
    machineConfigPoolSelector: Optional[Dict[str, str]] = Field(
        None,
        description='MachineConfigPoolSelector defines the MachineConfigPool label to use in the MachineConfigPoolSelector of resources like KubeletConfigs created by the operator. Defaults to "machineconfiguration.openshift.io/role=<same role as in NodeSelector label key>"',
    )
    net: Optional[Net] = Field(
        None, description='Net defines a set of network related features'
    )
    nodeSelector: Dict[str, str] = Field(
        ...,
        description='NodeSelector defines the Node label to use in the NodeSelectors of resources like Tuned created by the operator. It most likely should, but does not have to match the node label in the NodeSelector of the MachineConfigPool which targets this performance profile. In the case when machineConfigLabels or machineConfigPoolSelector are not set, we are expecting a certain NodeSelector format <domain>/<role>: "" in order to be able to calculate the default values for the former mentioned fields.',
    )
    numa: Optional[Numa] = Field(
        None, description='NUMA defines options related to topology aware affinities'
    )
    realTimeKernel: Optional[RealTimeKernel] = Field(
        None,
        description="RealTimeKernel defines a set of real time kernel related parameters. RT kernel won't be installed when not set.",
    )
    workloadHints: Optional[WorkloadHints] = Field(
        None,
        description='WorkloadHints defines hints for different types of workloads. It will allow defining exact set of tuned and kernel arguments that should be applied on top of the node.',
    )


class Condition(BaseModel):
    lastHeartbeatTime: Optional[datetime] = None
    lastTransitionTime: Optional[datetime] = None
    message: Optional[str] = None
    reason: Optional[str] = None
    status: str
    type: str = Field(
        ...,
        description="ConditionType is the state of the operator's reconciliation functionality.",
    )


class Status(BaseModel):
    conditions: Optional[List[Condition]] = Field(
        None,
        description='Conditions represents the latest available observations of current state.',
    )
    runtimeClass: Optional[str] = Field(
        None,
        description='RuntimeClass contains the name of the RuntimeClass resource created by the operator.',
    )
    tuned: Optional[str] = Field(
        None,
        description='Tuned points to the Tuned custom resource object that contains the tuning values generated by this operator.',
    )


class PerformanceProfile(BaseModel):
    apiVersion: Optional[str] = Field(
        None,
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ObjectMeta] = Field(
        None,
        description="Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
    )
    spec: Optional[Spec] = Field(
        None,
        description='PerformanceProfileSpec defines the desired state of PerformanceProfile.',
    )
    status: Optional[Status] = Field(
        None,
        description='PerformanceProfileStatus defines the observed state of PerformanceProfile.',
    )


class PerformanceProfileList(BaseModel):
    apiVersion: Optional[str] = Field(
        None,
        description='APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources',
    )
    items: List[PerformanceProfile] = Field(
        ...,
        description='List of performanceprofiles. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md',
    )
    kind: Optional[str] = Field(
        None,
        description='Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
    metadata: Optional[v1.ListMeta] = Field(
        None,
        description='Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds',
    )
